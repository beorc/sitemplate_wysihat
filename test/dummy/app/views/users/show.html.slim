h1 Users#show
p Find me in app/views/users/show.html.slim
p = @user.name
p = @user.email if @user.email

code
  pre
    ... except helpers. Why is it in Ruby that everything is an object, even integers, yet as soon as we need to format a date, we all turn into Dijkstra and bust out structured programming? Actually, come to think of it, Dijkstra wouldn't even write any code, because it's beneath him, but you get the idea. (if you don't get this, it's a joke. About proofs, telescopes, and CS...) Helpers are like a compliment that you don't want to give, but feel obligated to: "Yeah, I mean, well, you tried, and that's what counts, right?"

    This is the topic of a future post, but when programming in a langauge, you want to work with its primary methods of abstraction. In Ruby, that's objects, and there's a good reason for that: functions don't provide a sufficient amount of power to tackle hard problems. I don't want to get into this either, but there's a reason that objects exist, and that nobody's making procedural languages anymore. No biggie. C has a special place in my heart. 

= simple_form_for @user do |f|
  fieldset
    = f.input :biography, as: :sitemplate_rich_editor
  .form-actions
    = f.button :submit, :class => 'btn-primary'

= simple_form_for @user do |f|
  fieldset
    = f.input :biography, as: :sitemplate_rich_editor
  .form-actions
    = f.button :submit, :class => 'btn-primary'

code
  pre
    ... except helpers. Why is it in Ruby that everything is an object, even integers, yet as soon as we need to format a date, we all turn into Dijkstra and bust out structured programming? Actually, come to think of it, Dijkstra wouldn't even write any code, because it's beneath him, but you get the idea. (if you don't get this, it's a joke. About proofs, telescopes, and CS...) Helpers are like a compliment that you don't want to give, but feel obligated to: "Yeah, I mean, well, you tried, and that's what counts, right?"

    This is the topic of a future post, but when programming in a langauge, you want to work with its primary methods of abstraction. In Ruby, that's objects, and there's a good reason for that: functions don't provide a sufficient amount of power to tackle hard problems. I don't want to get into this either, but there's a reason that objects exist, and that nobody's making procedural languages anymore. No biggie. C has a special place in my heart. 
    ... except helpers. Why is it in Ruby that everything is an object, even integers, yet as soon as we need to format a date, we all turn into Dijkstra and bust out structured programming? Actually, come to think of it, Dijkstra wouldn't even write any code, because it's beneath him, but you get the idea. (if you don't get this, it's a joke. About proofs, telescopes, and CS...) Helpers are like a compliment that you don't want to give, but feel obligated to: "Yeah, I mean, well, you tried, and that's what counts, right?"
    ... except helpers. Why is it in Ruby that everything is an object, even integers, yet as soon as we need to format a date, we all turn into Dijkstra and bust out structured programming? Actually, come to think of it, Dijkstra wouldn't even write any code, because it's beneath him, but you get the idea. (if you don't get this, it's a joke. About proofs, telescopes, and CS...) Helpers are like a compliment that you don't want to give, but feel obligated to: "Yeah, I mean, well, you tried, and that's what counts, right?"

    This is the topic of a future post, but when programming in a langauge, you want to work with its primary methods of abstraction. In Ruby, that's objects, and there's a good reason for that: functions don't provide a sufficient amount of power to tackle hard problems. I don't want to get into this either, but there's a reason that objects exist, and that nobody's making procedural languages anymore. No biggie. C has a special place in my heart. 

    This is the topic of a future post, but when programming in a langauge, you want to work with its primary methods of abstraction. In Ruby, that's objects, and there's a good reason for that: functions don't provide a sufficient amount of power to tackle hard problems. I don't want to get into this either, but there's a reason that objects exist, and that nobody's making procedural languages anymore. No biggie. C has a special place in my heart. 
